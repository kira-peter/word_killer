# Design

## Overview
将节奏舞蹈模式从"单个单词"改为"滑动窗口式单词队列"，提供更好的视觉预览和连续的游戏体验。

## Architecture

### 1. 单词队列数据结构
```go
type RhythmDanceState struct {
    // 新增字段
    WordQueue          []string // 单词队列（固定长度5）
    CompletedHistory   []string // 已完成单词历史（最多保留2个）
    CurrentWordIndex   int      // 当前可输入的单词在队列中的索引（永远是2，中间位置）

    // 保留字段
    PointerPosition  float64
    PointerSpeed     float64
    // ... 其他统计字段
}
```

**说明**：
- `WordQueue[0-1]`：已完成的单词（历史记录，深灰→浅灰）
- `WordQueue[2]`：当前可输入的单词（白色高亮）
- `WordQueue[3-4]`：待输入的单词（预览，浅灰→深灰）

### 2. 核心逻辑流程

#### 初始化阶段
1. 生成初始5个随机单词，填充 `WordQueue`
2. `CurrentWordIndex` 设为 2（中间位置）
3. 前两个单词标记为"占位符"或空字符串（游戏开始时历史区为空）
4. 初始化节奏指针和其他状态

#### 游戏循环
```
每帧更新：
1. 更新节奏指针位置
2. 更新舞蹈动画
3. 检查倒计时

用户输入字母：
1. 验证输入是否匹配 WordQueue[2]（当前可输入单词）
2. 更新输入缓冲区
3. 高亮显示匹配字符

用户按空格/回车：
1. 检查输入是否完全匹配 WordQueue[2]
2. 执行节奏判定
3. 将 WordQueue[2] 移动到历史区（WordQueue[0] 被丢弃，全部上移）
4. 生成新单词追加到 WordQueue 末尾（WordQueue[4]）
5. 保持队列长度为5，当前单词始终在索引2
6. 清空输入缓冲区
```

### 3. UI布局设计

**初始状态（游戏刚开始）**：
```
┌─────────────────────────────────────────────────┐
│         Judgment History (■■■■)                │
├──────────────────┬──────────────────────────────┤
│ 左半屏（单词）  │  右半屏（节奏条+特效）      │
│                  │                              │
│     (空白)     ──┤  (历史区占位符)              │
│     (空白)     ──┤  (历史区占位符)              │
│  ───────────────┼──────────────────────────────┤
│ Input: hello  ══┤══[████RhythmBar████]═════════│ ← 当前行
│  ───────────────┼──────────────────────────────┤
│      world     ─┤  (浅灰 #888)                 │
│      code      ─┤  (深灰 #444)                 │
│                  │                              │
├──────────────────┴──────────────────────────────┤
│  Time: 60s | Score: 0 | Combo: 0x              │
└─────────────────────────────────────────────────┘
```

**运行状态（已完成若干单词后）**：
```
┌─────────────────────────────────────────────────┐
│         Judgment History (■■■■)                │
├──────────────────┬──────────────────────────────┤
│ 左半屏（单词）  │  右半屏（节奏条+特效）      │
│                  │                              │
│      hello     ──┤  (深灰 #444，已完成)        │
│      world     ──┤  (浅灰 #888，已完成)        │
│  ───────────────┼──────────────────────────────┤
│ Input: code   ══┤══[████RhythmBar████]═════════│ ← 当前行
│  ───────────────┼──────────────────────────────┤
│      game      ─┤  (浅灰 #888)                 │
│      play      ─┤  (深灰 #444)                 │
│                  │                              │
├──────────────────┴──────────────────────────────┤
│  Time: 45s | Score: 120 | Combo: 5x           │
└─────────────────────────────────────────────────┘
```

**布局规则**：
- **左半屏**：所有5个单词垂直排列，**靠右对齐**
- **右半屏**：节奏条、判定特效、舞蹈角色
- **颜色渐变方案**（从上到下）：
  - 位置0（已完成-2）：深灰色 `#444444`（初始状态为空白，不显示任何内容）
  - 位置1（已完成-1）：浅灰色 `#888888`（初始状态为空白，不显示任何内容）
  - **位置2（当前）**：行首显示 "Input: [完整单词]"
    - 始终显示完整的目标单词字符
    - 根据用户输入进行颜色编码：
      - 已正确输入的字符：绿色
      - 错误输入的字符：红色
      - 未输入的字符：白色
  - 位置3（待输入+1）：浅灰色 `#888888`
  - 位置4（待输入+2）：深灰色 `#444444`
- 节奏条仅显示在**当前单词（位置2）右侧**，**水平对齐**
- **空白占位符处理**：初始状态时，位置0-1为空字符串，渲染时不显示任何文字，保留行高以保持布局一致
- **输入显示示例**：
  ```
  Input: word     (未输入，"word" 全部白色)
  Input: word     (输入"wo"，"wo"=绿色，"rd"=白色)
  Input: word     (输入"wox"，"wo"=绿色，"x"=红色，"d"=白色)
  ```

### 4. 输入验证逻辑

**当前实现**（单单词）：
```go
if g.InputBuffer != g.RhythmDanceState.CurrentWord {
    // Miss判定
}
```

**新实现**（队列）：
```go
currentWord := g.RhythmDanceState.WordQueue[2] // 中间位置
if g.InputBuffer != currentWord {
    // Miss判定
}
```

**字母输入验证**：
```go
// 只验证是否匹配 WordQueue[2] 的前缀
currentWord := g.RhythmDanceState.WordQueue[2]
if !strings.HasPrefix(currentWord, g.InputBuffer + string(ch)) {
    // 拒绝输入或标记为错误
}
```

### 5. 单词补充策略

**场景**：完成 WordQueue[2]（当前单词）后
```go
func (g *Game) CompleteCurrentRhythmWord() {
    // 1. 整个队列上移（丢弃最老的历史单词）
    g.RhythmDanceState.WordQueue = g.RhythmDanceState.WordQueue[1:]

    // 2. 生成新单词追加到末尾（成为新的 upcoming+2）
    newWord := g.generateUniqueWord(g.RhythmDanceState.WordQueue)
    g.RhythmDanceState.WordQueue = append(g.RhythmDanceState.WordQueue, newWord)

    // 3. 保持队列长度为5，当前单词始终在索引2
    // (已自动满足，因为移除1个+追加1个)

    // 4. 清空输入
    g.InputBuffer = ""
}
```

**效果示例**：
```
完成前：[hist-2, hist-1, *current*, next+1, next+2]
         索引: 0      1       2        3      4

完成后：[hist-1, *current*, next+1, next+2, NEW]
         索引: 0       1        2       3      4
                       ↑ 原来的next+1变成了新的current
```

### 6. 性能考虑

**单词生成**：
- 预生成队列，避免运行时卡顿
- 使用现有的 `pickRandomWord()` 方法

**渲染优化**：
- 只在单词队列变化时重新计算布局
- 避免每帧重绘整个单词列表

## Trade-offs

### 方案1：固定5个单词（采用）
✅ 优点：
- 布局简单，易于实现
- 性能稳定，队列长度恒定
- 用户体验一致

❌ 缺点：
- 缺乏灵活性，无法适配不同屏幕尺寸

### 方案2：可配置数量（未采用）
✅ 优点：
- 灵活性高
- 可根据用户偏好调整

❌ 缺点：
- 增加配置复杂度
- 需要动态布局计算
- 可能影响游戏平衡

### 方案3：自适应屏幕高度（未采用）
✅ 优点：
- 最佳屏幕利用率

❌ 缺点：
- 实现复杂度高
- 不同设备体验差异大
- 难以平衡难度

## Open Questions
- ❓ 是否需要显示单词编号（1. word1, 2. word2...）？
- ❓ 完成单词后是否需要过渡动画（如淡出效果）？
- ❓ 未完成单词的颜色方案（纯灰色 vs 暗色高亮）？
