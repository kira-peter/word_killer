# Technical Design: Classic Game Mode

## Context
Word Killer 的第一个可玩版本，需要在命令行环境中实现流畅的实时打字游戏体验。核心挑战包括：
- 无阻塞的键盘输入处理
- 高性能的屏幕渲染
- 精确的时间和统计数据跟踪
- 良好的跨平台兼容性

**约束条件**:
- 必须在命令行运行
- 需要低延迟（< 50ms 输入响应）
- 跨平台支持（Windows、macOS、Linux）

## Goals / Non-Goals

**Goals**:
- 提供流畅的 60fps 渲染体验
- 准确的输入匹配和即时反馈
- 完整的游戏数据统计
- 简洁清晰的代码架构

**Non-Goals**:
- 网络多人对战（后续版本）
- 图形界面（专注于 CLI）
- 持久化存储（第一版暂不保存历史记录）
- 复杂的动画效果

## Decisions

### 1. 架构模式: Event-Driven + MVC
**决策**: 采用事件驱动架构 + MVC 分层
- **Model**: 游戏状态、单词数据、统计数据
- **View**: 命令行渲染层
- **Controller**: 输入处理和游戏逻辑控制

**理由**:
- 清晰的职责分离
- 便于测试和维护
- 事件驱动适合实时输入处理

**替代方案**:
- 单体架构：代码耦合度高，难以测试
- 组件化架构：对于第一版过度设计

### 2. 键盘事件库选择
**推荐方案**: `github.com/eiannone/keyboard`
- 轻量级，无额外依赖
- 跨平台支持良好
- API 简单直观

**替代方案**:
- `github.com/nsf/termbox-go`: 功能更全但较重
- `github.com/mattn/go-runewidth`: 仅处理字符宽度

### 3. UI 渲染策略
**决策**: 使用 ANSI 转义序列 + 手动缓冲区管理

**方案细节**:
```go
// 屏幕刷新策略
- 清屏: ANSI escape codes
- 光标控制: 移动到指定位置渲染
- 颜色高亮: ANSI 颜色代码
- 双缓冲: 先构建完整帧，再一次性输出
```

**理由**:
- 最大控制灵活性
- 性能最优（无框架开销）
- 学习成本低

**替代方案**:
- `bubbletea`: 功能强大但引入额外复杂度
- `termui`: 过于重量级

### 4. 单词匹配算法
**决策**: 前缀匹配 + 最长公共前缀高亮

**算法**:
```
1. 用户每次输入，遍历所有未消除单词
2. 检查输入是否为某个单词的前缀
3. 匹配则高亮该单词（可能多个）
4. 回车时，选择完全匹配的单词消除
```

**优化**:
- 使用 Trie 树优化查找（如单词数量 > 1000）
- 第一版简单遍历即可（< 50 个单词）

### 5. 游戏状态管理
**决策**: 集中式状态对象

```go
type GameState struct {
    Status       GameStatus  // Idle, Running, Paused, Finished
    Words        []Word      // 当前屏幕单词
    InputBuffer  string      // 当前输入
    Stats        Statistics  // 统计数据
    StartTime    time.Time
    PauseTime    time.Time   // 暂停时间
    TotalPausedDuration time.Duration  // 累计暂停时长
}
```

**线程安全**: 使用 mutex 保护状态访问（输入和渲染可能并发）

### 6. 数据统计实现
**决策**: 事件触发式累加

每个用户操作触发相应计数器更新:
- 按键 → TotalKeystrokes++
- 匹配字符 → ValidKeystrokes++, CorrectChars++
- 消除单词 → WordsCompleted++, TotalLetters += len(word)

速度计算: 实时根据 elapsed time 计算（需排除暂停时长）

### 7. 单词词库管理
**决策**: 配置文件驱动

**第一版实现**:
- 使用简单的文本文件存储单词（每行一个单词）
- 配置文件指定词库文件路径
- 游戏启动时加载到内存

**后续扩展**:
- 支持下载官方词库
- 支持多个词库切换
- 词库分类（难度、主题等）

**单词选择规则**:
- 每场游戏不出现重复单词
- 不限制单词数量和长度
- 从词库随机抽取

### 8. 暂停功能设计
**决策**: 模态暂停菜单

**交互流程**:
1. 游戏中按 ESC 键进入暂停菜单
2. 暂停时屏幕显示菜单：
   - 继续 (Resume)
   - 结束 (Quit)
3. 上下方向键选择选项
4. 回车键确认选择
5. 暂停菜单中再次按 ESC 键退出游戏

**状态处理**:
- 暂停时停止计时（记录暂停开始时间）
- 恢复时扣除暂停时长
- 暂停时忽略所有游戏输入，仅响应菜单操作

**退出流程**:
- 游戏中按 ESC：进入暂停菜单
- 暂停菜单中按 ESC：退出游戏

## Risks / Trade-offs

### 风险 1: 跨平台终端兼容性
**风险**: 不同终端对 ANSI 代码支持不一致
**缓解**:
- 检测终端能力，降级到基本渲染
- 测试主流终端（Windows Terminal、iTerm2、GNOME Terminal）

### 风险 2: 输入延迟
**风险**: 键盘事件处理可能阻塞渲染
**缓解**:
- 输入和渲染分离到不同 goroutine
- 使用 channel 通信，避免阻塞

### 权衡: 性能 vs 功能
**选择**: 第一版优先保证核心体验流畅
- 暂不实现复杂动画
- 单词数量根据词库大小，但保证不重复
- 后续版本再优化和扩展

## Migration Plan
这是全新功能，无需迁移。

**部署步骤**:
1. 编译可执行文件
2. 打包单词词库
3. 提供简单的使用说明
4. 发布 v0.1.0

**回滚**: 无需回滚策略（全新项目）

## Open Questions
- [x] **单词词库来源** - ✅ 已确认：来自配置文件指定的文本文件，现在用简单文件，将来支持下载官方词库
- [x] **游戏难度设置** - ✅ 已确认：单词数量和长度不限制，但每场游戏不出现重复单词
- [x] **暂停功能** - ✅ 已确认：需要暂停功能，暂停时显示菜单（继续/结束），上下键选择
- [x] **错误输入惩罚** - ✅ 已确认：无惩罚机制，错误输入仅影响统计数据（准确率等）

所有问题已确认，可以开始实施。
