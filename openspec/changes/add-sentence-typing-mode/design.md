## Context
当前 Word Killer 仅支持经典单词消除模式。为了扩展游戏的玩法和练习场景，需要添加句子打字模式。句子模式更贴近真实打字场景，包含标点符号、空格等元素，能够提供更全面的打字练习体验。

**约束条件**:
- 必须保持与经典模式的统计系统兼容
- UI 需要清晰区分两种模式
- 两种模式的切换应该流畅自然

**相关方**:
- 用户：需要简单直观的模式选择和游戏体验
- 开发者：需要可扩展的模式架构，便于未来添加更多模式

## Goals / Non-Goals

**Goals**:
- 支持经典模式和句子模式的共存
- 提供清晰的模式选择界面
- 实现句子模式的核心玩法：逐字符输入、颜色标识正确/错误、支持删除
- 复用现有统计系统，适配句子模式的统计需求
- 保持代码结构清晰，便于未来扩展更多模式

**Non-Goals**:
- 不实现句子的分级难度系统（句子文件中所有句子平等对待）
- 不实现多句子连续打字（单次游戏只打一个句子）
- 不实现句子的智能推荐或学习系统
- 不修改已有的经典模式逻辑

## Decisions

### 决策 1: 游戏模式枚举
**选择**: 在 `pkg/game/game.go` 中定义 `GameMode` 类型作为枚举
```go
type GameMode int

const (
    ModeClassic GameMode = iota
    ModeSentence
)
```

**理由**:
- 类型安全，避免字符串魔法值
- 便于 switch-case 处理不同模式逻辑
- 未来扩展新模式只需添加新常量

**备选方案**:
- 使用字符串 "classic" / "sentence"：不够类型安全，容易拼写错误
- 使用接口抽象模式：过度设计，当前只有两种模式且逻辑差异不大

### 决策 2: 句子数据存储
**选择**: 使用 `Game` 结构体的 `TargetSentence` 和 `UserInput` 字段存储句子模式数据

**理由**:
- 句子模式不需要复杂的单词列表结构
- 复用现有的 `Game` 结构体，避免创建新的游戏状态类
- `UserInput` 直接存储用户的完整输入，便于逐字符比对

**备选方案**:
- 创建 `SentenceGame` 结构体：会导致代码重复和状态管理复杂化
- 复用 `Words` 字段存储句子：语义不清晰，违反单一职责原则

### 决策 3: 字符匹配和颜色标识
**选择**: 在 UI 渲染层进行逐字符对比，根据位置匹配关系应用颜色
```go
// 伪代码示例
for i, ch := range userInput {
    if i < len(targetSentence) {
        if ch == targetSentence[i] {
            // 绿色显示
        } else {
            // 红色显示
        }
    }
}
```

**理由**:
- 渲染逻辑放在 UI 层，保持职责分离
- 游戏逻辑层只负责数据存储和状态管理
- 实时对比，无需预处理

**备选方案**:
- 在游戏逻辑层预计算正确/错误字符列表：增加状态复杂度，且每次输入都需重新计算

### 决策 4: 模式选择流程
**选择**: 欢迎页面选择 "start" → 进入模式选择页面 → 选择模式后开始游戏

**理由**:
- 遵循用户明确的意图表达：先确定要玩，再选择玩法
- 模式选择页面可以展示每种模式的简短说明
- 未来可以在模式选择页面添加更多选项（如难度设置）

**备选方案**:
- 在欢迎页面直接列出所有选项（Classic / Sentence / Quit）：选项过多时界面会混乱
- 通过配置文件指定默认模式：对新用户不友好，减少探索性

### 决策 5: 完成判定
**选择**: 当 `len(UserInput) == len(TargetSentence)` 且用户按回车时，游戏结束

**理由**:
- 允许用户完整输入句子后再提交，符合打字练习的自然流程
- 即使有错误也允许提交，用户可以看到最终结果和准确率
- 回车作为明确的提交信号，避免误触

**备选方案**:
- 完全正确时自动结束：剥夺了用户的主动权，可能造成困惑
- 必须完全正确才能提交：过于严格，不利于初学者

## Risks / Trade-offs

### 风险 1: 句子文件为空或格式错误
**缓解措施**:
- 在加载句子时进行验证，如果文件为空或读取失败，显示友好错误信息
- 提供默认的示例句子文件

### 风险 2: 统计系统不适配句子模式
**缓解措施**:
- 句子模式下统计逻辑与单词模式类似：总字符数、正确字符数、速度、准确率
- 复用现有 `Statistics` 结构体和方法，只需调整计算逻辑

### 风险 3: 两种模式的代码分支过多，难以维护
**缓解措施**:
- 在关键方法中使用 `if g.Mode == ModeClassic { ... } else { ... }` 明确区分
- 如果未来模式增多，再考虑重构为策略模式或状态模式

### Trade-off: 简单实现 vs 可扩展架构
**选择**: 优先选择简单实现
- 当前只有两种模式，使用条件分支足够清晰
- 过早抽象可能导致过度设计
- 如果未来模式数量超过 3-4 个，再重构为接口抽象

## Migration Plan

无需迁移，这是新增功能。

**向后兼容性**:
- 现有的经典模式逻辑完全不变
- 配置文件增加可选字段 `sentence_dict_path`，如果不存在则使用默认值

## Open Questions

无
